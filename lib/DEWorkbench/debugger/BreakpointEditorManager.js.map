{"version":3,"file":"BreakpointEditorManager.js","sourceRoot":"","sources":["../../../src/DEWorkbench/debugger/BreakpointEditorManager.ts"],"names":[],"mappings":"AAAA,WAAW,CAAA","sourcesContent":["'use babel'\n\n/*!\n * Dynamic Engine Workbench\n * Copyright(c) 2017 Dynamic Engine Team @ Vipera Plc\n * MIT Licensed\n *\n * Based on xatom-debug plugin\n * XAtom Debug\n * Copyright(c) 2017 Williams Medina <williams.medinaa@gmail.com>\n * MIT Licensed\n *\n */\n\n/**\nimport { Breakpoint, Breakpoints } from './DebuggerCommons'\nimport { BreakpointManager } from './BreakpointManager'\n\nimport {\n createIcon,\n createText,\n createInput,\n createButton,\n createElement,\n insertElement,\n attachEventFromObject\n} from '../../element/index'\n\n//import { PluginManager } from '../plugin/index'\n//import { InspectorView } from '../inspector/index'\nimport { EventEmitter }  from 'events'\nimport { get } from 'lodash'\n\nexport interface EditorOptions {\n//  pluginManager: PluginManager,\n  didAddBreakpoint?: Function,\n  didRemoveBreakpoint?: Function,\n  didEvaluateExpression?: Function,\n  didBreak?: Function,\n  didChange?: Function\n}\n\nexport class DebuggerEditorManager {\n\n  private currentEditor: any\n\n  private currentBreakMarker: any\n  private currentExpressionMarker: any\n  private currentEvaluationMarker: any\n  private currentEvaluationElement: HTMLElement\n\n  private activateExpressionListerner: boolean = true\n  private evaluateHandler: any\n\n  public breakpointManager: BreakpointManager\n  private pluginManager: PluginManager\n  private events: EventEmitter\n\n  constructor (options: EditorOptions) {\n    this.events = new EventEmitter()\n    this.breakpointManager = new BreakpointManager()\n//    this.pluginManager = options.pluginManager\n    attachEventFromObject(this.events, [\n      'didAddBreakpoint',\n      'didRemoveBreakpoint',\n      'didChangeBreakpoint',\n      'didEvaluateExpression',\n      'didBreak',\n      'didChange'\n    ], options)\n  }\n\n  restoreBreakpoints (breakpoints: Breakpoints) {\n    breakpoints.forEach(({filePath, lineNumber, condition}) => {\n      let marker\n      if (get(this, 'currentEditor.getPath') && filePath === this.currentEditor.getPath()) {\n        marker = this.createBreakpointMarkerForEditor(this.currentEditor, lineNumber)\n      }\n      this.breakpointManager.addBreakpoint(marker, lineNumber, filePath, condition)\n      this.events.emit('didAddBreakpoint', filePath, lineNumber)\n    })\n  }\n\n  getBreakpointFromEvent (event: any) {\n    let line: HTMLElement = event.target\n    let lineNumber = parseInt(line.getAttribute('data-buffer-row'), 0)\n    let editor = atom.workspace.getActiveTextEditor()\n    let filePath = editor.getPath()\n    return this.breakpointManager.getBreakpoint(filePath, lineNumber)\n  }\n\n  removeBreakpointFromEvent (event: any) {\n    let breakpoint = this.getBreakpointFromEvent(event)\n    if (breakpoint) {\n      this.removeBreakpoint(breakpoint)\n    }\n  }\n\n  editBreakpointFromEvent (event: any) {\n    let editor = atom.workspace.getActiveTextEditor()\n    let breakpoint = this.getBreakpointFromEvent(event)\n    if (breakpoint) {\n      let range = [[breakpoint.lineNumber, 0], [breakpoint.lineNumber, 0]]\n      let marker: any = editor.markBufferRange(range)\n      let conditionInput = document.createElement('atom-text-editor')\n      conditionInput.setAttribute('mini', 'true')\n      let miniEditor = conditionInput['getModel']()\n      miniEditor.setText(breakpoint.condition)\n      miniEditor.setGrammar(editor.getGrammar())\n      let conditionButton = createButton({\n        click: () => {\n          let miniEditor = conditionInput['getModel']()\n          let conditionText = miniEditor.getText()\n          breakpoint.condition = conditionText\n          setTimeout(() => {\n            this.events.emit('didChangeBreakpoint', breakpoint.filePath, breakpoint.lineNumber, breakpoint.condition)\n            this.pluginManager.changeBreakpoint(breakpoint.filePath, breakpoint.lineNumber, breakpoint.condition)\n            this.events.emit('didChange')\n          }, 500)\n          breakpointEditor.remove()\n          marker.destroy()\n        }\n      }, createIcon('check'))\n      // conditionButton.classList.add('btn-success')\n\n      let breakpointEditor: HTMLElement = createElement('div', {\n        elements: [\n          conditionInput,\n          conditionButton,\n          createElement('bugs-breakpoint-edit-arrow')\n        ]\n      })\n      let decorator = editor.decorateMarker(marker, {\n        type: 'overlay',\n        class: 'bugs-breakpoint-edit',\n        item: breakpointEditor\n      })\n      setTimeout(() => {\n        conditionInput.focus()\n        conditionInput.addEventListener('blur', (e: FocusEvent) => {\n          if(e.relatedTarget !== conditionButton) {\n            breakpointEditor.remove()\n            marker.destroy()\n          }\n        })\n      }, 0)\n    }\n  }\n\n  destroy () {\n    this.currentBreakMarker = undefined\n    this.currentExpressionMarker = undefined\n    this.currentEvaluationMarker = undefined\n    this.removeMarkers()\n  }\n\n  breakOnFile (filePath: string, lineNumber: number) {\n    // this.createConsoleLine('', [\n    //   createText('Break on'),\n    //   createText(`${filePath}:${lineNumber}`)\n    // ])\n    this.events.emit('didBreak', filePath, lineNumber)\n  }\n\n  createBreakMarker (editor, lineNumber: number) {\n    this.removeBreakMarker()\n    let range = [[lineNumber, 0], [lineNumber, 0]]\n    this.currentBreakMarker = editor.markBufferRange(range)\n    editor.decorateMarker(this.currentBreakMarker, {\n      type: 'line',\n      class: 'bugs-break-line'\n    })\n  }\n\n  removeMarkers () {\n    this.removeBreakMarker()\n    this.removeExpressionMarker()\n    this.removeEvaluationMarker()\n  }\n\n  removeBreakMarker () {\n    if (this.currentBreakMarker) {\n      this.currentBreakMarker.destroy()\n    }\n  }\n\n  removeExpressionMarker () {\n    if (this.currentExpressionMarker) {\n      this.currentExpressionMarker.destroy()\n    }\n  }\n\n  async addFeatures (editor) {\n    // restore breakpoints\n    if (get(editor, 'getPath', false)) {\n      let sourceFile = editor.getPath()\n      let breakpoints = await this.breakpointManager.getBreakpointsFromFile(sourceFile)\n      breakpoints.forEach((breakpoint: Breakpoint) => {\n        if (breakpoint.marker) breakpoint.marker.destroy()\n        breakpoint.marker = this.createBreakpointMarkerForEditor(editor, breakpoint.lineNumber)\n      })\n      this.currentEditor = editor\n      if (get(editor, 'element.addEventListener', false) &&\n        !get(editor, 'element.__atomBugsEnabledFeatures', false)) {\n        let breakpointHandler = (e) => this.addBreakpointFromEvent(e, editor)\n        let expressionHandler = (e) => this.listenExpressionEvaluations(e, editor)\n        // add breakpoint handler\n        editor.element.__atomBugsEnabledFeatures = true\n        editor.element.addEventListener('click', breakpointHandler)\n        editor.element.addEventListener('mousemove', expressionHandler)\n        editor.onDidDestroy(() => {\n          editor.element.removeEventListener('click', breakpointHandler)\n          editor.element.removeEventListener('mousemove', expressionHandler)\n        })\n      }\n    }\n  }\n\n  private removeBreakpoint (breakpoint: Breakpoint) {\n    let sourceFile = breakpoint.filePath\n    let lineNumber = breakpoint.lineNumber\n    return this\n      .breakpointManager\n      .removeBreakpoint(breakpoint)\n      .then(() => {\n        this.events.emit('didRemoveBreakpoint', sourceFile, lineNumber)\n        this.pluginManager.removeBreakpoint(sourceFile, lineNumber)\n      })\n  }\n\n  private addBreakpointFromEvent (e: MouseEvent, editor: any) {\n    let element = e.target as HTMLElement\n    if (element.classList.contains('line-number')) {\n      // toggle breakpoints\n      let lineNumber = Number(element.textContent) - 1\n      if (lineNumber >= 0) {\n        let sourceFile = editor.getPath()\n        let exists = this.breakpointManager.getBreakpoint(sourceFile, lineNumber)\n        if (exists) {\n          this.removeBreakpoint(exists)\n        } else {\n          let marker = this.createBreakpointMarkerForEditor(editor, lineNumber)\n          this\n            .breakpointManager\n            .addBreakpoint(marker, lineNumber, sourceFile)\n            .then(() => {\n              this.events.emit('didAddBreakpoint', sourceFile, lineNumber)\n              this.pluginManager.addBreakpoint(sourceFile, lineNumber)\n            })\n        }\n        this.events.emit('didChange')\n      }\n    }\n  }\n\n  private createBreakpointMarkerForEditor (editor: any, lineNumber: any) {\n    let range = [[lineNumber, 0], [lineNumber, 0]]\n    let marker = editor.markBufferRange(range)\n    let decorator = editor.decorateMarker(marker, {\n      type: 'line-number',\n      class: 'bugs-breakpoint'\n    })\n    return marker\n  }\n\n  private getEditorPositionFromEvent (editor, e: MouseEvent) {\n    let lines = editor.element.querySelector('.lines')\n    var clientX = e.clientX\n    var clientY = e.clientY\n    let clientRect = lines.getBoundingClientRect()\n    let screenPosition = editor.element.screenPositionForPixelPosition({\n      top: (clientY - clientRect.top) + editor.element.getScrollTop(),\n      left: (clientX - clientRect.left) + editor.element.getScrollLeft()\n    })\n    return editor.bufferPositionForScreenPosition(screenPosition)\n  }\n\n  private getEditorWordRangeFromPosition (editor, position) {\n    let prevRow = editor.buffer.previousNonBlankRow(position.row)\n    let endRow = editor.buffer.nextNonBlankRow(position.row)\n    if (!endRow) {\n      endRow = position.row\n    }\n    let startWord = position\n    let endWord = position\n    // /\\()\"':,.<>~!@#$%^&*|+=[]{}`?-â€¦\n    editor.scanInBufferRange(/[ \\,\\{\\}\\(\\\\)\\[\\]^\\n]+/gm, [[prevRow, 0], position], (s) => {\n      if (s.matchText) {\n        startWord = s.range.end\n      }\n    })\n    editor.scanInBufferRange(/[ \\,\\{\\}\\(\\.\\\\)\\[\\]\\:\\/\\n]+/g, [position, [endRow, 50]], (s) => {\n      if (s.matchText) {\n        endWord = s.range.start\n        s.stop()\n      }\n    })\n    return [startWord, endWord]\n  }\n\n  private listenExpressionEvaluations (e: MouseEvent, editor: any) {\n    let sourceFile = editor.getPath()\n    let bufferPosition = this.getEditorPositionFromEvent(editor, e)\n    let scanRange = this.getEditorWordRangeFromPosition(editor, bufferPosition)\n    let expression = editor.getTextInBufferRange(scanRange)\n    clearTimeout(this.evaluateHandler)\n    this.evaluateHandler = setTimeout(() => {\n      let isEvaluationOverlay = this.currentEvaluationElement && this.currentEvaluationElement.contains(e.target as Node)\n      let isValidExpression = expression && expression.toString().trim().length > 0\n      if (!isEvaluationOverlay && isValidExpression) {\n        let evaluationView = this.createEditorEvaluationView(editor, scanRange)\n        this.pluginManager.evaluateExpression(expression, evaluationView)\n      } else if (!isEvaluationOverlay) {\n        this.removeEvaluationMarker()\n        this.removeExpressionMarker()\n      }\n    }, 2000)\n  }\n\n  createEditorEvaluationView (editor: any, range: any) {\n    return {\n      insertFromResult: (result) => {\n        this.addEditorEvaluationMarker(editor, result, range)\n      }\n    }\n  }\n\n  createInspectorOverlay (result: any) {\n    let element = createElement('xatom-debug-overlay', {\n      className: 'native-key-bindings'\n    })\n    element.setAttribute('tabindex', '0')\n    let inspector = new InspectorView({\n      result,\n      didRequestProperties: (result, inspectorView) => {\n        this.pluginManager.requestProperties(result, inspectorView)\n      }\n    })\n    return insertElement(element, [\n      createElement('xatom-debug-overlay-header', {\n        elements: [ createText(result.className || result.type) ]\n      }),\n      inspector.getElement()\n    ])\n  }\n\n  addEditorEvaluationMarker (editor: any, result: any, range) {\n    // highlight expression\n    this.removeExpressionMarker()\n    this.currentExpressionMarker = editor.markBufferRange(range)\n    editor.decorateMarker(this.currentExpressionMarker, {\n      type: 'highlight',\n      class: 'bugs-expression'\n    })\n    // overlay inspector\n    this.removeEvaluationMarker()\n    this.currentEvaluationElement = this.createInspectorOverlay(result)\n    this.currentEvaluationMarker = editor.markBufferRange(range)\n    editor.decorateMarker(this.currentEvaluationMarker, {\n      type: 'overlay',\n      class: 'bugs-expression-overlay',\n      item: this.currentEvaluationElement\n    })\n    setTimeout(() => {\n      // this.currentEvaluationElement.addEventListener('mouseleave', () => {\n      //   this.removeEvaluationMarker()\n      //   this.removeExpressionMarker()\n      // })\n      // let close = () => {\n      //   this.activateExpressionListerner = true\n      //   this.removeEvaluationMarker()\n      //   this.removeExpressionMarker()\n      // }\n      // let autoClose = setTimeout(close, 15000)\n      // element.addEventListener('mouseenter', () => {\n      //   // clearTimeout(autoClose)\n      //   this.activateExpressionListerner = false\n      //   // element.addEventListener('mouseleave', () => close())\n      // })\n    }, 250)\n  }\n\n  removeEvaluationMarker () {\n    if (this.currentEvaluationMarker) {\n      this.currentEvaluationMarker.destroy()\n      this.currentEvaluationMarker = undefined\n    }\n  }\n}\n**/\n"]}